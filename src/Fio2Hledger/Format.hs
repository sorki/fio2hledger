{-# LANGUAGE DataKinds #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}

module Fio2Hledger.Format where

import Control.Applicative
import Data.Text (Text)
import Data.Text.Lazy.Builder (Builder)
import Data.Time.Calendar (Day)
import Data.Time.Format (FormatTime)
import API.Fio (AccountStatement(..), Payment(..))
import Money (SomeDense)

import qualified Data.Bool
import qualified Data.Maybe
import qualified Data.Map
import qualified Data.Text
import qualified Data.Text.Lazy.Builder
import qualified Data.Text.Lazy
import qualified Data.Time.Calendar
import qualified Data.Time.Format
import qualified Data.List
import qualified Money
import qualified Safe

import Hledger hiding (amount)
import Data.Function (on)
import Text.Pretty.Simple

import Fio2Hledger.Types

-- | Format @AccountStatement@ into multiple hledger journals,
-- grouped by year.
formatAccountStatements
  :: Config
  -> AccountStatement SomeDense
  -> [(Text, Builder)]
formatAccountStatements cfg as =
  map
    (\year ->
       (formatYear . tdate . head . head $ year
       , statementPreamble as <> formatYearlyTransactions (pure year)
       ))
    (groupTransactions cfg as)

-- | Format @AccountStatement@ into hledger journal format
-- with outshine headers separating years and months
formatAccountStatement
  :: Config
  -> AccountStatement SomeDense
  -> Builder
formatAccountStatement cfg as =
      statementPreamble as
  <> formatYearlyTransactions (groupTransactions cfg as)

groupTransactions
  :: Config
  -> AccountStatement SomeDense
  -> [[[Transaction]]]
groupTransactions cfg as =
  map
    (Data.List.groupBy
      ((==) `on` (getM . tdate))
    )
    $ Data.List.groupBy
        ((==) `on` (getY . tdate))
        ts
  where
    ts = map (fioPayment2Transaction cfg) (transactions as)
    getY day = let (y, _, _) = Data.Time.Calendar.toGregorian day in y
    getM day = let (_, m, _) = Data.Time.Calendar.toGregorian day in m

-- | Builder for @Transaction@s grouped by year
formatYearlyTransactions :: [[[Transaction]]] -> Builder
formatYearlyTransactions =
    mconcat
  . map
    (\year ->
          commentHeader False (formatYear . tdate . head . head $ year)
      <> formatMonthlyTransactions year)

-- | Builder for @Transaction@s grouped by month
formatMonthlyTransactions :: [[Transaction]] -> Builder
formatMonthlyTransactions =
    mconcat
  . map
    (\month ->
           commentHeader True (formatMonth . tdate . head $ month)
       <> mconcat (map (Data.Text.Lazy.Builder.fromText . showTransaction) month))

statementPreamble :: AccountStatement SomeDense -> Builder
statementPreamble AccountStatement{..} = mconcat $ map (("; "<>) . (<> "\n") . Data.Text.Lazy.Builder.fromText) [
          "-*- mode: HLedger; eval: (outshine-minor-mode 1); -*-"
        , "Generated by fio2hledger"
        , "* Account statement"
        , "** Account info"
        , "*** ID"
        , Data.Text.pack $ show accountId
        , "*** Bank ID"
        , Data.Text.pack $ show bankId
        , "*** IBAN"
        , iban
        , "*** BIC"
        , bic
        , "** Transactions"
        ]

-- | Format single payment to hledger @Transaction@
fioPayment2Transaction :: Config -> Payment SomeDense -> Transaction
fioPayment2Transaction cfg px@Payment{..} =
  balanceOrDie $ nulltransaction
  { tdate        = date
  , tcode        = Data.Text.pack . show $ remoteId
  , tdescription = Data.Maybe.fromMaybe "" typ
  , tcomment     = Data.Maybe.fromMaybe "" message
  , tpostings    = [
      (post
        ("fio:" <> Data.Text.toLower (Money.someDenseCurrency amount))
        $ convertAmount amount
      ) { pcomment = ourAccountPostingTags }

    , (post
        ("fio:"
          <> Data.Text.toLower (Money.someDenseCurrency amount)
          <> ":"
          <> formatRemote cfg px)
        missingamt
      ) { pcomment =
            remoteAccountPostingTags
            <> Data.Bool.bool
                  mempty
                  ("\n" <> Data.Text.Lazy.toStrict (pShowNoColor px))
                  (dumpPretty cfg)
        }
    ]
  }
  where
    convertAmount amt = Money.withSomeDense amt $ \denseValue ->
      let currency = Money.denseCurrency denseValue
      in nullamt
        { acommodity = amtCommodity currency
        , astyle = amtStyle currency
        , aquantity =
            Safe.readNote "Cannot read quantity in convertAmount"
            $ Data.Text.unpack
            $ Money.denseToDecimal
                Money.defaultDecimalConf
                Money.Round
                denseValue
        }

    -- Balance this transaction, shouldn't ever fail
    -- since our second posting is always nullamt (for now..)
    balanceOrDie :: Transaction -> Transaction
    balanceOrDie t = case balanceTransaction mempty t of
      Right x -> x
      Left er -> error $ "Can't balance transaction, error was: " ++ er

    -- Use custom style for CZK
    amtStyle "CZK" = czkStyle
    amtStyle _ = amountstyle { asprecision = Precision 2 }

    -- adjust to nice symbol if EUR
    amtCommodity "EUR" = "€"
    amtCommodity x = x

    tags :: [Maybe (Text, Text)] -> Text
    tags =
      Data.Text.intercalate ", "
      . map (\(tn, tv) -> tn <> ": " <> Data.Text.replace "," "" tv)
      -- filter empty values
      . filter (not . Data.Text.null . Data.Text.strip . snd)
      -- deduplicate tags with the same contents
      . Data.Bool.bool id (Data.List.nubBy ((==) `on` snd)) (deduplicate cfg)
      . Data.Maybe.catMaybes

    ourAccountPostingTags :: Text
    ourAccountPostingTags = tags [
        ("comment",)  <$> comment
      , ("constant",) <$> constantSym
      , ("variable",) <$> variableSym
      , ("specific",) <$> specificSym
      , ("user",)     <$> userIdent
      ]

    remoteAccountPostingTags = tags $ [
        ("remoteName",)     <$> remoteAcctName
      , ("remoteBankName",) <$> remoteBankName
      , ("bic",)            <$> bIC
      ] ++ maybe mempty parseComment comment

-- Build remote account name based on transaction type
formatRemote
  :: Config
  -> Payment SomeDense
  -> Text
formatRemote Config{..} x  | isCardPayment x =
  accountExpenses <> ":" <> accountCard
formatRemote Config{..} x  | isAtmWithdrawal x =
  accountExpenses <> ":" <> accountATM
formatRemote Config{..} x  | isBankFee x =
  accountExpenses <> ":" <> accountFees
formatRemote Config{..} x  | isInterest x =
  accountIncome <> ":" <> accountInterest
formatRemote Config{..} x  =
     (if isPositive (amount x) then accountIncome else accountExpenses)
  <> ":"
  <> Data.Maybe.fromMaybe
        (formatAccountNumber x)
        (Data.Map.lookup  (formatAccountNumber x) accountMap)

-- Utils

-- | True if SomeDense value is >0
isPositive :: SomeDense -> Bool
isPositive amt = Money.withSomeDense amt (>0)

-- | Format remote account number and remote bank number
-- to formet/latter format or empty Text when not available.
formatAccountNumber :: Payment a -> Text
formatAccountNumber Payment{..} =
      Data.Maybe.fromMaybe mempty remoteAcctNum
  <> maybe mempty ("/"<>) remoteBankNum

-- | Is this payment a fee we pay to a bank?
isBankFee :: Payment a -> Bool
isBankFee Payment{..} =
  typ == Just "Poplatek"
  && Data.Maybe.isNothing remoteAcctNum

-- | Is this payment a fee we pay to a bank?
isInterest :: Payment a -> Bool
isInterest Payment{..} =
  typ == Just "Připsaný úrok"
  && Data.Maybe.isNothing remoteAcctNum

-- | Is this a card payment?
isCardPayment :: Payment a -> Bool
isCardPayment p@Payment{..} =
  typ == Just "Platba kartou"
  && not (isAtmWithdrawal p)

-- | Is this an ATM withdrawal?
isAtmWithdrawal :: Payment a -> Bool
isAtmWithdrawal Payment{..} =
  typ == Just "Platba kartou"
  && (Data.Text.isPrefixOf "Výběr z bankomatu" <$> comment) == Just True

parseComment :: Text -> [Maybe (Text, Text)]
parseComment c =
  map Just
  $ case
      fmap (map Data.Text.strip)
      $ Data.Text.splitOn
          ","
        <$> (Data.Text.stripPrefix "Nákup: " c
              <|> Data.Text.stripPrefix "Výběr z bankomatu: " c)
    of
    -- new format
    Just [seller, loc, city, postal, country, _date, _amt]
      -> [ ("seller",  seller)
          , ("location",  loc)
          , ("city",  city)
          , ("postal",  postal)
          , ("country",  country)
          ]
    -- old format
    Just [seller, loc, country, _date, _amt]
      -> [ ("seller",  seller)
          , ("location",  loc)
          , ("country",  country)
          ]
    _ -> []


-- Output utils

commentHeader :: Bool -> Text -> Builder
commentHeader nested msg = Data.Text.Lazy.Builder.fromText
  $ "; ***"
   <> Data.Bool.bool mempty "*" nested
   <> " "
   <> msg
   <> "\n"

formatDate :: FormatTime t => String -> t -> Text
formatDate fmt = Data.Text.pack . Data.Time.Format.formatTime Data.Time.Format.defaultTimeLocale fmt

formatYear :: Day -> Text
formatYear = formatDate "%Y"

formatMonth :: Day -> Text
formatMonth = formatDate "%B"
